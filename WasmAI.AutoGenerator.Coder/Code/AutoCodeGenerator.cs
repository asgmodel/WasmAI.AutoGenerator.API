using AutoGenerator.ApiFolder;
using AutoGenerator.Code;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

public class BaseGenerator : ITGenerator
{
    private string generatedCode = string.Empty;
    public event EventHandler<string>? OnCodeGenerated;
    public event EventHandler<string>? OnCodeSaved;

    public static  bool UseAI { get; set; } = false;
    public static bool UseMG { get; set; } = false;

    private static readonly List<ITGenerator> tGenerators = new List<ITGenerator>();
    public static ICollection<ITGenerator> TGenerators => tGenerators;

    public bool IsEditFile { get; set; } = false;

    private string _filePath = string.Empty;

    private  GenerationOptions? _options;
    public GenerationOptions? Options => _options;



    public string Generate(GenerationOptions options)
    {
        _options = options;
        if (options == null)
            throw new ArgumentNullException(nameof(options), "Generation options cannot be null.");

        if (string.IsNullOrWhiteSpace(options.ClassName))
            throw new ArgumentException("Class name cannot be null or empty.", nameof(options.ClassName));

        if (string.IsNullOrWhiteSpace(options.Template))
            throw new ArgumentException("Template cannot be null or empty.", nameof(options.Template));

        var propertyDeclarations = new List<string>();
        if (options.Properties != null)
        {
            foreach (var prop in options.Properties)
            {
                if (prop == null || prop.PropertyType == null || string.IsNullOrWhiteSpace(prop.Name))
                    continue;

                var typeName = CodeGeneratorUtils.GetPropertyTypeName(prop.PropertyType);
                propertyDeclarations.Add($@"public {typeName} {prop.Name} {{ get; set; }}");
            }
        }

        var baseClass = string.Empty;
        if (!string.IsNullOrWhiteSpace(options.BaseClass))
        {
            baseClass = $": {options.BaseClass}";
            if (options.Interfaces?.Any() == true)
                baseClass += ", ";
        }
        else if (options.Interfaces?.Any() == true)
        {
            baseClass = ": ";
        }

        var interfaces = (options.Interfaces != null && options.Interfaces.Any())
            ? string.Join(", ", options.Interfaces.Select(i => i.Name))
            : string.Empty;

        var replacements = new Dictionary<string, string>
        {
            { "ClassName", options.ClassName },
            { "Properties", string.Join(Environment.NewLine, propertyDeclarations) },
            { "AdditionalCode", options.AdditionalCode ?? "" },
            { "Interfaces", interfaces },
            { "BaseClass", baseClass }
        };

        generatedCode = CodeGeneratorUtils.ApplyTemplate(options.Template, replacements);

        var classSyntax = SyntaxFactory.ParseMemberDeclaration(generatedCode)
            ?? throw new InvalidOperationException("Failed to parse class syntax from template.");

        var namespaceName = string.IsNullOrWhiteSpace(options.NamespaceName) ? "AutoGenerated" : options.NamespaceName;

        var namespaceDeclaration = SyntaxFactory.NamespaceDeclaration(SyntaxFactory.ParseName(namespaceName))
            .AddMembers(classSyntax);

        if (options.Usings == null)
            options.Usings = new List<string>();

        if (!options.Usings.Contains("System"))
            options.Usings.Add("System");


        var root = ApiFolderInfo.ROOT.Name;
        if (ApiFolderInfo.IsBPR)
            options.Usings.Add($"{root}.BPR.Layers.Base");

        var usingDirectives = options.Usings
            .Where(ns => !string.IsNullOrWhiteSpace(ns))
            .Select(ns => SyntaxFactory.UsingDirective(SyntaxFactory.ParseName(ns)))
            .ToArray();

        var compilationUnit = SyntaxFactory.CompilationUnit()
            .AddUsings(usingDirectives)
            .AddMembers(namespaceDeclaration)
            .NormalizeWhitespace();

        generatedCode = compilationUnit.ToFullString();

        OnCodeGenerated?.Invoke(this, generatedCode);
        _options.Template = generatedCode;
        tGenerators.Add(this);
        return generatedCode;
    }

    public  void SaveToFile(string filePath)
    {
        if (!string.IsNullOrWhiteSpace(filePath))
            _filePath = filePath;
        if (string.IsNullOrWhiteSpace(filePath))
            throw new ArgumentException("File path cannot be null or empty.", nameof(filePath));

        if (string.IsNullOrWhiteSpace(generatedCode))
            throw new InvalidOperationException("No generated code to save.");

        var directory = Path.GetDirectoryName(filePath);
        if (!string.IsNullOrWhiteSpace(directory) && !Directory.Exists(directory))
            Directory.CreateDirectory(directory);

        if (!File.Exists(filePath) || IsEditFile)
        {
            File.WriteAllText(filePath, generatedCode);
            Console.WriteLine($"Generated code saved to {filePath}");
            OnCodeSaved?.Invoke(this, filePath);
           
        }
        else if(UseMG)
        {
            
            try
            {
               var  merger= new ComprehensiveCodeMerger3();
                generatedCode = merger.MergeCode(File.ReadAllText(filePath), generatedCode, "old_version.cs", "new_version.cs", ISUseAI());
                File.WriteAllText(filePath, generatedCode);
                Console.WriteLine($"Merged code saved to {filePath}");
                OnCodeSaved?.Invoke(this, filePath);
            }


            catch (Exception ex)
            {
                Console.WriteLine($"Error merging code: {ex.Message}");
                // Handle the exception as needed
            }

            // throw new IOException("File already exists and overwriting is disabled.");
        }
        else
        {
            
            generatedCode = File.ReadAllText(filePath);
        }

    }


    bool ISUseAI()
    {
        if(!UseAI)
        return false;

        return this is ControllerGenerator || this is ValidatorGenerator ||this is ServiceGenerator;
    }
    public string GetCode()
    {
       return generatedCode;
    }

    public string GetFilePath()
    {
        return _filePath;
    }
}
